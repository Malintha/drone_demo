#!/usr/bin/env python3

import argparse
try:
    from cStringIO import StringIO
except ImportError:
    from io import StringIO
from distutils.dir_util import copy_tree
import math
import os
import re
import subprocess
import sys
import tempfile

# from em import Interpreter
from gazebo_msgs.srv import DeleteModel
from gazebo_msgs.srv import DeleteModelRequest
from gazebo_msgs.srv import SpawnModel
from gazebo_msgs.srv import SpawnModelRequest
from rosgraph import ROS_MASTER_URI
from rospkg import RosPack
from rospy import ServiceProxy
from rospy import myargv as rospy_myargv
from rospy import wait_for_service


def spawn_model(model_name, model_xml,
    pose, ros_master_uri=None, robot_namespace=None, debug=True,
    service_name='/gazebo/spawn_sdf_model',
):
    x, y, yaw = pose
    INITIAL_HEIGHT = 0.5 # m

    if ros_master_uri:
        original_uri = os.environ[ROS_MASTER_URI]
        os.environ[ROS_MASTER_URI] = ros_master_uri
    wait_for_service(service_name)
    srv = ServiceProxy(service_name, SpawnModel)

    if debug:
        print(model_xml)

    req = SpawnModelRequest()
    req.model_name = model_name
    req.model_xml = model_xml
    req.robot_namespace = robot_namespace if robot_namespace else model_name
    req.initial_pose.position.x = x
    req.initial_pose.position.y = y
    req.initial_pose.position.z = INITIAL_HEIGHT
    req.initial_pose.orientation.x = 0.0
    req.initial_pose.orientation.y = 0.0
    req.initial_pose.orientation.z = math.sin(yaw / 2.0)
    req.initial_pose.orientation.w = math.cos(yaw / 2.0)
    req.reference_frame = ''

    resp = srv(req)

    if ros_master_uri:
        os.environ[ROS_MASTER_URI] = original_uri

    if resp.success:
        print(resp.status_message, '(%s)' % model_name)
        return 0
    else:
        print(resp.status_message, file=sys.stderr)
        return 1

def delete_model(model_name, ros_master_uri=None, robot_namespace=None,
    service_name='/gazebo/delete_model'):

    if ros_master_uri:
        original_uri = os.environ[ROS_MASTER_URI]
        os.environ[ROS_MASTER_URI] = ros_master_uri
    wait_for_service(service_name)
    srv = ServiceProxy(service_name, DeleteModel)

    req = DeleteModelRequest()
    req.model_name = model_name
 
    resp = srv(req)

    if ros_master_uri:
        os.environ[ROS_MASTER_URI] = original_uri

    if resp.success:
        print(resp.status_message, '(%s)' % model_name)
        return 0
    else:
        print(resp.status_message, file=sys.stderr)
        return 1


def get_px4_dir():
    rp = RosPack()
    return rp.get_path('px4')


def seed_rootfs(rootfs):
    px4_dir = get_px4_dir()
    copy_tree(px4_dir, rootfs)


def run_px4(rootfs, rc_script='etc/init.d-posix/rcS', px4_sim_model='iris', vehicle_id='0'):
    """ Replacing run_px4.sh'
    rc_script is the path to the rc_script to run
    px4_sim_model is the model
    if rootfs is set use that for the rootfs, otherwise run in a temporary directory.
    """
    if not rootfs:

            return run_px4(rc_script, px4_sim_model, tempdir)

    print("using rootfs ", rootfs)
    seed_rootfs(rootfs)

    cmd = ['px4', '%s/ROMFS/px4fmu_common' % rootfs, 
           '-s', rc_script,
           '-i', vehicle_id,
           '-d']
    print("running px4 with command: ", cmd)
    subprocess_env = os.environ.copy()
    subprocess_env['PX4_SIM_MODEL'] = px4_sim_model
    child = subprocess.Popen(
        cmd,
        cwd=rootfs,
        env=subprocess_env)
    return child

model_files = {
    'iris': '/home/osrf/diux/src/sitl_gazebo/models/iris_fpv_cam/iris_fpv_cam.sdf',
    'plane': '/home/osrf/diux/src/sitl_gazebo/models/plane_cam/plane_cam.sdf',
    'typhoon': '/home/osrf/diux/src/sitl_gazebo/models/typhoon_h480/typhoon_h480.sdf',
}
valid_models = {
    'iris': 'rosrun xacro xacro %(description_path)s/urdf/%(drone_type)s_base.xacro rotors_description_dir:=%(description_path)s mavlink_udp_port:=%(mavlink_udp_port)s mavlink_tcp_port:=%(mavlink_tcp_port)s --inorder',
    'plane': 'rosrun xacro xacro %(description_path)s/urdf/%(drone_type)s_base.xacro rotors_description_dir:=%(description_path)s mavlink_udp_port:=%(mavlink_udp_port)s mavlink_tcp_port:=%(mavlink_tcp_port)s --inorder',
    'typhoon_h480': 'rosrun xacro xacro %(description_path)s/urdf/%(drone_type)s_base.xacro rotors_description_dir:=%(description_path)s mavlink_udp_port:=%(mavlink_udp_port)s mavlink_tcp_port:=%(mavlink_tcp_port)s --inorder',
}

starting_poses={
    '0': (0,0,0),
    '1': (0,1,0),
    '2': (0,2,0),
    '3': (0,3,0),
}


class Drone:
    def __init__(self, drone_type, pose=(0,0,0), vehicle_id='0'):
        assert drone_type in valid_models.keys()
        self.drone_type = drone_type
        self.pose = pose
        self.vehicle_id = vehicle_id
        self.vehicle_name = self.drone_type+'_%s' % self.vehicle_id
        assert int(vehicle_id) <= 10

        import rospkg
        rp = rospkg.RosPack()
        description_path = os.path.join(rp.get_path('mavlink_sitl_gazebo'), 'models/rotors_description')
        self.arguments = {
            'description_path': description_path,
            'drone_type': drone_type,
            'mavlink_tcp_port': 4560 + int(vehicle_id),
            'mavlink_udp_port': 14560 + int(vehicle_id),
        }

        self.xml = subprocess.check_output(valid_models[drone_type] % self.arguments, shell=True).decode('utf-8')

    def spawn(self):
        spawn_model(self.vehicle_name, self.xml, self.pose)

    def unspawn(self):
        delete_model(self.vehicle_name)
    
    def wait(self):
        if self.autopilot_process:
            self.autopilot_process.wait()

    def __enter__(self):
        self.spawn()
        self.rootfs = tempfile.TemporaryDirectory()
        self.autopilot_process = run_px4(self.rootfs.name, 'etc/init.d-posix/rcS', self.drone_type, self.vehicle_id)
        return self

    def __exit__(self, exc_type, exc_value, exc_traceback):
        if exc_type is KeyboardInterrupt:
            print("Caught keyboard interrupt tearing down")
        print("Stopping Autopilot")
        self.autopilot_process.terminate()
        self.autopilot_process.wait()
        self.rootfs.cleanup()
        print('Cleaned up autopilot %s' % self.vehicle_id)
        print('Deleting Model %s' % self.vehicle_name)
        self.unspawn()
        print('Finished deleting model')
        if exc_type is KeyboardInterrupt:
            return True
        # TODO(tfoote) unspawn

def main():
    SUPPORTED_DRONE_TYPES=['typhoon_h480', 'iris', 'plane']

    parser = argparse.ArgumentParser(description='Spawn a drone')
    parser.add_argument('drone_type', help="What type of drone", choices=SUPPORTED_DRONE_TYPES)
    parser.add_argument('--pose-id', help="What position to start in", choices=['0','1','2','3'], default='0', type=str)

    myargv = rospy_myargv(argv=sys.argv)[1:]
    print("myargv", myargv)
    args = parser.parse_args(args=myargv)
    drone = Drone(args.drone_type, starting_poses[args.pose_id], args.pose_id)
    with drone as d:
        d.wait()
        print("exiting")

if __name__ == '__main__':
    main()